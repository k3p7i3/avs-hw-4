##  Копырина Полина Ивановна, группа БПИ213   
##  Контакты для коммуникации: @apollo_k в Телеграме
#   Индивидуальное домашнее задание №4. Вариант 5.

## Задание:
###    Задача об обедающих философах. Пять философов сидят возле круглого стола. Они проводят жизнь, чередуя приемы пищи и размышления. В центре стола находится большое блюдо спагетти. Спагетти длинные и запутанные, философам тяжело управляться с ними, поэтому каждый из них, что бы съесть порцию, должен пользоваться двумя вилками. К несчастью, философам дали только пять вилок. Между каждой парой философов лежит одна вилка, поэтому эти высококультурные и предельно вежливые люди договорились, что каждый будет пользоваться только теми вилками, которые лежат рядом с ним (слева и справа). Написать многопоточную программу, моделирующую поведение философов с помощью семафоров. Программа должна избегать фатальной ситуации, в которой все философы голодны, но ни один из них не может взять обе вилки (например, каждый из философов держит по одной вилки и не хочет отдавать ее). Решение должно быть симметричным, то есть все потоки-философы должны выполнять один и тот же код.

##  4 балла
### Входные данные
На вход программе подаются четыре положительных числа типа _int_: 
>min_eat_time, max_eat_time, min_meditate_time, max_meditate_time.

Эти 4 числа последовательно образуют два диапазона, ограничивающие следующие значения соответственно: время, которое философ тратит на поедание спагетти (в секундах), и время, которое тратится на размышления о великом (тоже в секундах).

То есть, когда философ(поток) хочет поесть/поразмышлять, он тратит на это время _n_ секунд,
где min_time <= n <= max_time. Данное _n_ генерируется случайным образом как раз перед выполнением действия.

Причем, входные данные должны удовлетворять следующим условиям: минимальное время должно быть не больше максимального, и числа должны быть строго положительными (хотелось бы, конечно, уметь возвращать время вспять, но мы так еще не научились).

### Формат входных и выходных данных

Задавать вышеописанные 4 числа можно аж 3 способами:
1. через консоль
2. через командную строку
3. чтением из файла

Но для этого нужно **обязательно указать способ чтения первым аргументом в командной строке** при запуске приложения.
1. Чтобы ввести данные через консоль, нужно первым аргументом указать опцию **_--console_input_**.
> ./code --console_input \
> 15 20 8 10
2. Чтобы ввести данные через консоль, нужно первым аргументом указать опцию **_--command_input_**, и сразу после этого ввести 4 входных параметра.
> ./code --command_input 15 20 8 10
3. Чтобы ввести данные с помощью чтения из файла, нужно первым аргументом указать опцию **_--file_input_*, и сразу после этого ввести имя файла, из которого читать данные.
> ./code --file_input input.txt

Так же есть 2 формата выходных данных - через терминал и через файл.\
Терминал является способом вывода по умолчанию. \
Чтобы выводить данные в файл, нужно в командной строке при запуске программы указать опцию **_--file_output_**, и сразу за ней написать имя файла, в который выводить сообщения (так как способ входных данных задается первым, то эту опцию надо писать после описания форматы входных данных).
Примеры запуска программы с выводом в файл:
> ./code --console_input --file_output output.txt\
> 15 20 8 10

> ./code --command_input 15 20 8 10 --file_output output.txt

> ./code --file_input input.txt

### Что вообще делать с программой
Как только вы запустите программу (смотреть запуск в описании входных данных), программа начнет выводить о деятельности философов сообщения вида
"Философ №i начал думать о жизни, и это займет n секунд", "Философ №i закончил кушать". \
Есть выходные данные выводятся в консоль, то вы будете видеть сообщения сразу. \
Если выводите в файл - то только после того, как программа завершиться (поток main должен синхронизироваться с другими потоками). \
Для того, чтобы завершить выполнение программы (не аварийно, а так, чтобы увидеть вывод данных в файл), введите в терминал **q**. Программа не сразу, но остановится (просто подождите, философам нужно доделать свои дела...) \
Вы прекрасны - у вас есть отчет о деятельности философов!

### Модель параллельных вычислений
Думаю, лучше всего под решение этой задачи подходит модель **итеративный параллелизм**. Из общих сведений, приведенных перед вариантами заданий:
>Итеративный параллелизм используется для реализации нескольких потоков (часто идентичных), каждый из которых
>содержит циклы. Потоки программы, описываются итеративными функциями и работают совместно над решением одной задачи.

Здесь каждый поток представляет собой философа, и каждый философ выполняет "бесконечный" (пока пользователь 
не завершит выполнение программы) - чередование философских раздумий и трапезы спагетти. И, как можно 
заметить, потоки идентичны (так как в условии написано, что решение симметрично, то есть потоки выполняют один и тот же код).

##  5 баллов
В файле с программой **code.c** добавлены поясняющие комментарии. 

### Предметная область и объекты программы
В нашей предметной области есть две сущности - философы и вилки (всех по 5 штук). Философы в программе - это параллельные потоки, живущие своей жизнью. Вилки - это своеобразный ресурс, использовать который в один и тот же момент может максимум 1 философ (поток). \
Философы - потоки выполняют две функции (действия) в "бесконечном" цикле - кушают и философствуют.
Когда философ (поток) философствует, ему не нужны ресурсы, поэтому он просто "размышляет" какое-то время (поток просто засыпает, такая вот имитация деятельности).
Когда философ голоден и хочет поесть, сначала ему нужно завладеть вилками (а одной вилкой может владеть только 1 философ, это условие выполняется с помощью семафоров).  \
Философ, как культурный человек, ждет, когда сосед-философ закончит есть и положит вилку обратно (ресурс-вилка освободится), и только после этого забирает вилку себе. Когда философ-поток завладеет двумя вилками, он начинает есть ими (спит, но ресурсы-вилки все еще его). \
Когда философ закончил есть, он освобождает вилки-ресурсы, и дальше идет философствовать.

##  6 баллов
Сценарий работы программы.
1. Программа (главный поток) получает входные данные.
2. Программа (главный поток main) инициализирует семафоры.
3. Программа создает 5 потоков (pthreads) философов.
4. Как только поток main считывает символ q, потоки-философы стараются закончить свою работу (не сразу, так как им нужно завершить итерацию цикла "жизнедеятельности").
5. Main синхронизируется с потоками.
6. Main разрушает семафоры.

Более подробно про работу потоков-философов:
1. Поток философ создался, при создании ему был дан номер (для идентификации).
2. Поток-философ pthread начинает цикл из действий meditate() и eat().
3. Когда поток заходит в функцию meditate, для него генерируется время, которое он будет "размышлять".
4. Перед началом размышлений поток захватывает поток выходных данных с помощью rwlock (почти как мьютекс, но для ресурсов чтения-записи), и пишет туда, что сейчас будет размышлять n секунд.
5. Поток засыпает на n секунд.
6. Поток просыпается, ждет, пока не освободится rwlock, захватываем rwlock и пишет сообщение, что закончил думать. После этого выходит из функции.

7. Когда поток заходит в функцию eat, для него генерируется время, которое он будет "есть спагетти".
8. Существует семафор **take_forks**, который регулирует, что пытаться захватить ресурс в одно время может не больше 4 потоков (тогда хотя бы один что-то да захватит и покушает). Если его не будет, то может случиться так, что 5 потоков стараются захватить вилки, и каждый захватит ровно по 1, и будут сидеть все голодные и с 1 вилкой в руках...)
9. Поток ждет, пока не сможет "зайти" в семафор take_forks. Когда заходит, начинает ждать, пока не освободится правая вилка (семафор, соответствующий i-ой вилке). 
10. Когда семафор **forks[i]** освобождается, поток захватывает его, и теперь аналогично  пытается захватить **forks[(i + 1) % 5]** - две близлежащие вилки.
11. Поток осовобождает от себя семафор take_forks, ведь вилками-семафорами он уже завладел.
12. Перед началом работы трапезы захватывает поток выходных данных с помощью rwlock, и пишет туда, что сейчас будет есть n секунд.
13. Поток засыпает на n секунд.
13. Поток просыпается, ждет, пока не освободится rwlock, захватываем rwlock и пишет сообщение, что закончил кушать.
14. Поток освобождает два семафора-вилки: forks[i] и forks[(i + 1)% 5]. После этого выходит из функции.

##  7 баллов
В папке **tests** хранятся примеры входных данных и результаты выходных данных (правда, каждый результат зависит и от того, когда пользователь решил выйти из программы).
Файлы с входными файлами называются **inputi.txt**, а с результатами вычислений - **outputi.txt**, где i - номер теста.
К сожалению, примеров не очень много, так как программа выполняет довольно однообразные действия,
и чтобы она завершилась, нужно сидеть и тыкать-завершать тесты вручную, поэтому тестов не очень много...


##  8 баллов
Все данные содержатся в программе. \
Функция генерации рандомных чисел - **generate_time**.

P.S. Спасибо за курс!